header {
package bitnots.parse;

import bitnots.expressions.*;
import bitnots.theories.*;

import java.util.*;
}

/**
* A parser generated by the <a href="http://www.antlr.org/">ANTLR</a>
* tools.  When paired with a BitnotsScanner, matches files that
* contain definitions used to aid in proving any matched targets.
* Each matched element returns an object of the type that corresponds
* to it (ie. matching a formulaType will return a Formula object).
* @author <a href="mailto:walpet@bethel.edu">Pete Wall</a>
* @author ANTLR
* @version 1.0
*/
class BitnotsParser extends Parser;
options
{
    k = 3;
    defaultErrorHandler=false;
}

{
/**
* True if definitions found are only there to put their names into
* Symbol's table.  If not, the definitions are added into a list
* inside a definitions HashMap.
*/
private boolean formatOnly = false;

/**
* True if we are currently reading a def-conjecture element.  This is
* important because when we read a free variable inside a def-conjecture,
* we turn it into a constant.  All other times, we turn it into a
* sequent variable.
*/
private boolean inTarget = false;
}

/**
* Matches a file, which consists of elements.  Those elements are to
* be put into a definitions HashMap.
* @param defs the HashMap to place definitions into.
* @throws NestedBindingException if a bound variable is used later as
* the bound variable in an FOLFormula, a class term, or an iota term.
*/
file [HashMap defs]
    throws NestedBindingException
    : (element[defs])* EOF
    ;

/**
* Matches an element, which can be a (format-only ...) switch, an
* (include "...") file include, or a (def-??? ...) definition.  If
* formatOnly is false, the definition will be added to the
* corresponding list inside defs.
* @param defs The HashMap to place definitions into.
* @throws NestedBindingException if a bound variable is used later as
* the bound variable in an FOLFormula, a class term, or an iota term.
*/
element [HashMap defs]
    throws NestedBindingException
    {
        TheoryElement t = null;     // The TheoryElement that the matched
                                    //      defintion corresponds to.
        String fileInclude = null;  // The filename in an include element.
    }
    : formatOnlyType
    | fileInclude=fileIncludeType
        {
            ((ArrayList) defs.get("fileincludes")).add(fileInclude);
        }
    | t=defAxiomType
        {
            if (!this.formatOnly)
                ((HashSet) defs.get("axioms")).add(t);
        }
    | t=defLemmaType
        {
            if (!this.formatOnly)
                ((HashSet) defs.get("lemmas")).add(t);
        }
    | t=defPredicateType
        {
            if (!this.formatOnly)
                ((HashSet) defs.get("predicates")).add(t);
        }
    | t=defTargetType
        {
            if (!this.formatOnly)
                ((ArrayList) defs.get("targets")).add(t);
        }
    | t=defTermType
        {
            if (!this.formatOnly)
                ((HashSet) defs.get("terms")).add(t);
        }
    | t=defTheoremType
        {
            if (!this.formatOnly)
                ((HashSet) defs.get("theorems")).add(t);
        }
    ;

/**
* Matches an axiom definition in the form of: <code>(def-axiom
* <i>axiom_name</i> <i>fomula</i> (string "axiom description"))
* </code>.
* @throws NestedBindingException if a bound variable is used later as
* the bound variable in an FOLFormula, a class term, or an iota term.
* @return a TheoryElement object that corresponds to this axiom.
*/
defAxiomType
    returns [TheoryElement te = null]
    throws NestedBindingException
    {
        ArrayList bvs = new ArrayList();    // The bound variables that will be
                                            //  tracked.
        HashMap others = new HashMap();    // The free variables that will be
                                            //  tracked.
        Formula f = null;                   // The Axiom formula.
        String id = null;                   // The Axiom's name.
        String desc = null;                 // The Axiom's description.
    }
    : OPEN_P "def-axiom" id=identifier f=formulaType[bvs, others]
        (desc=stringType)? CLOSE_P
        {
            te = new Axiom(f, id, desc);
        }
    ;

/**
* Matches a lemma definition in the form of: <code>(def-lemma
* <i>lemma_name</i> <i>formula</i> (string "lemma description"))
* </code>.
* @throws NestedBindingException if a bound variable is used later as
* the bound variable in an FOLFormula, a class term, or an iota term.
* @return a TheoryElement object that corresponds to this lemma.
*/
defLemmaType
    returns [TheoryElement te = null]
    throws NestedBindingException
    {
        ArrayList bvs = new ArrayList();    // The bound variables that will be
                                            //  tracked.
        HashMap others = new HashMap();    // The free variables that will be
                                            //  tracked.
        Formula f = null;                   // The Lemma's formula.
        String id = null;                   // The Lemma's name.
        String desc = null;                 // The Lemma's description.
    }
    : OPEN_P "def-lemma" id=identifier f=formulaType[bvs, others]
        (desc=stringType)? CLOSE_P
        {
            te = new Lemma(f, id, desc);
        }
    ;

/**
* Matches a predicate definition in the form of: <code>(def-predicate
* <i>predicate</i> <i>formula</i> (string "predicate description")
* (format "usage format"))</code>.
* @throws NestedBindingException if a bound variable is used later as
* the bound variable in an FOLFormula, a class term, or an iota term.
* @return a TheoryElement object that corresponds to this predicate.
*/
defPredicateType
    returns [TheoryElement te = null]
    throws NestedBindingException
    {
        ArrayList bvs = new ArrayList();    // The bound variables that will be
                                            //  tracked.
        HashMap others = new HashMap();    // The free variables that will be
                                            //  tracked.
        Formula pred = null;                // The Predicate's predicate.
        Formula form = null;                // The Predicate's formula.
        String desc = null;                 // The Predicate's description.
        String format = null;
    }
    : OPEN_P "def-predicate" pred=predicateType[bvs, others]
        form=formulaType[bvs, others] (format=formatType)? (desc=stringType)?
        CLOSE_P
        {
            te = new PredicateDefinition((Predicate) pred, form, format, desc);
        }
    ;

/**
* Matches a target definition in the form of: <code>(def-conjecture
* <i>target_name</i> <i>formula</i> (string "target description"))
* </code>.
* @throws NestedBindingException if a bound variable is used later as
* the bound variable in an FOLFormula, a class term, or an iota term.
* @return a TheoryElement object that corresponds to this target.
*/
defTargetType
    returns [TheoryElement te = null]
    throws NestedBindingException
    {
        ArrayList bvs = new ArrayList();    // The bound variables that will be
                                            //  tracked.
        HashMap others = new HashMap();     // The constants variables that will
                                            //  be tracked.
        Formula f = null;                   // The Conjecture's formula.
        String id = null;                   // The Conjecture's name.
        String desc = null;                 // The Conjecture's description.
    }
    : OPEN_P "def-conjecture"
            { this.inTarget = true; }
        id=identifier f=formulaType[bvs, others] (desc=stringType)? CLOSE_P
        {
            te = new Conjecture(f, id, desc);
            this.inTarget = false;
        }
    ;

/**
* Matches a term definition in the form of: <code>(def-term
* <i>term</i> </i>term</i> (string "term description") (format "usage
* format"))</code>.
* @throws NestedBindingException if a bound variable is used later as
* the bound variable in an FOLFormula, a class term, or an iota term.
* @return a TheoryElement object that corresponds to this term.
*/
defTermType
    returns [TheoryElement te = null]
    throws NestedBindingException
    {
        ArrayList bvs = new ArrayList();    // The bound variables that will be
                                            //  tracked.
        HashMap others = new HashMap();    // The free variables that will be
                                            //  tracked.
        ComplexTerm term1 = null;                  // The Term's definiendum.
        ComplexTerm term2 = null;                  // The Term's definiens.
        String desc = null;                 // The Term's description.
        String format = null;               // The Term's format string.
    }
    : OPEN_P "def-term" term1=termType[bvs, others] term2=termType[bvs, others]
        (format=formatType)? (desc=stringType)? CLOSE_P
        {
            te = new TermDefinition(term1, term2, format, desc);
        }
    ;

/**
* Matches a theorem definition in the form of: <code>(def-knowledge
* <i>theorem_name</i> <i>formula</i> (string "theorem description"))
* </code>.
* @throws NestedBindingException if a bound variable is used later as
* the bound variable in an FOLFormula, a class term, or an iota term.
* @return a TheoryElement object that corresponds to this theory.
*/
defTheoremType
    returns [TheoryElement te = null]
    throws NestedBindingException
    {
        ArrayList bvs = new ArrayList();    // The bound variables that will be
                                            //  tracked.
        HashMap others = new HashMap();    // The free variables that will be
                                            //  tracked.
        Formula f = null;                   // The Theorem's formula.
        String id = null;                   // The Theorem's name.
        String desc = null;                 // The Theorem's description.
    }
    : OPEN_P "def-knowledge" id=identifier f=formulaType[bvs, others]
        (desc=stringType)? CLOSE_P
        {
            te = new Theorem(f, id, desc);
        }
    ;

/**
* Matches a formula, which could be either <code>(truth)</code> or
* <code>(falsity)</code>, a propositional formula, a first-order logic
* formula, or a predicate formula.
* @param bvs the list of bound varibles so far.
* @param others the list of free varibles or constants so far.
* @throws NestedBindingException if a bound variable is used later as
* the bound variable in an FOLFormula, a class term, or an iota term.
* @return A Formula object corresponding to this formula.
*/
formulaType [ArrayList bvs, HashMap others]
    returns [Formula f = null]
    throws NestedBindingException
    : OPEN_P CLOSE_P
    | (OPEN_P ("and"|"or"|"not"|"implies"|"iff")) => f=propType[bvs, others]
    | (OPEN_P ("forall"|"for-some")) => f=folType[bvs, others]
    | f=predicateType[bvs, others]
    | OPEN_P "truth" CLOSE_P
        {
            LogicalConstructor ps = (LogicalConstructor) Symbol.putOrGet(
                                            LogicalConstructor.class, "truth");
            f = FormulaFactory.getFormula(ps, null);
        }
    | OPEN_P "falsity" CLOSE_P
        {
            LogicalConstructor ps = (LogicalConstructor) Symbol.putOrGet(
                                        LogicalConstructor.class, "falsity");
            f = FormulaFactory.getFormula(ps, null);
        }
    ;

/**
* Matches a propositional formula in the form of: <code>(<i>type
* formula more formulas?</i>)</code>, where type and the number of
* formulas for that type are "and":2+, "or":2+, "not":1, "implies":2,
* "iff":2.
* @param bvs the list of bound varibles so far.
* @param others the list of free varibles or constants so far.
* @throws NestedBindingException if a bound variable is used later as
* the bound variable in an FOLFormula, a class term, or an iota term.
* @return A Formula object corresponding to this propositional
* formula.
*/
propType [ArrayList bvs, HashMap others]
    returns [Formula f = null]
    throws NestedBindingException
    {
        List list = new ArrayList();    // The arguments in this propositional
                                        //   formula.
        Formula form = null;            // A formula object that will be matched
                                        //   in this propositional formula.
    }
    : OPEN_P "and" form=formulaType[bvs, others]
            { list.add(form); }
        (form=formulaType[bvs, others]
            { list.add(form); }
        )+ CLOSE_P
        {
            PropositionalConstructor ps;
            ps = (PropositionalConstructor) Symbol.putOrGet(
                                        PropositionalConstructor.class, "and");
            f = FormulaFactory.getFormula(ps, new Object[] {list});
        }
    | OPEN_P "or" form=formulaType[bvs, others]
            { list.add(form); }
        (form=formulaType[bvs, others]
            { list.add(form); }
        )+ CLOSE_P
        {
            PropositionalConstructor ps;
            ps = (PropositionalConstructor) Symbol.putOrGet(
                                        PropositionalConstructor.class, "or");
            f = FormulaFactory.getFormula(ps, new Object[] {list});
        }
    | OPEN_P "not" form=formulaType[bvs, others]
            { list.add(form); }
        CLOSE_P
        {
            PropositionalConstructor ps;
            ps = (PropositionalConstructor) Symbol.putOrGet(
                                        PropositionalConstructor.class, "not");
            f = FormulaFactory.getFormula(ps, new Object[] {list});
        }
    | OPEN_P "implies" form=formulaType[bvs, others]
            { list.add(form); }
        form=formulaType[bvs, others]
            { list.add(form); }
        CLOSE_P
        {
            PropositionalConstructor ps;
            ps = (PropositionalConstructor) Symbol.putOrGet(
                                    PropositionalConstructor.class, "implies");
            f = FormulaFactory.getFormula(ps, new Object[] {list});
        }
    | OPEN_P "iff" form=formulaType[bvs, others]
            { list.add(form); }
        form=formulaType[bvs, others]
            { list.add(form); }
        CLOSE_P
        {
            PropositionalConstructor ps;
            ps = (PropositionalConstructor) Symbol.putOrGet(
                                        PropositionalConstructor.class, "iff");
            f = FormulaFactory.getFormula(ps, new Object[] {list});
        }
    ;

/**
* Matches a first-order logic formula in the form of: <code>(<i>type
* </i>(<i>variables</i>) <i>formula</i>)</code>, where type is either
* "forall" or "for-some", and variables is one or more variables
* inside parens.
* @param bvs the list of bound varibles so far.
* @param others the list of free varibles or constants so far.
* @throws NestedBindingException if a bound variable is used later as
* the bound variable in an FOLFormula, a class term, or an iota term.
* @return A Formula object corresponding to this first-order logic
* formula.
*/
folType [ArrayList bvs, HashMap others]
    returns [Formula f = null]
    throws NestedBindingException
    {
        ArrayList localBVS = new ArrayList();   // The list of variables made
                                    // bound by this FOL formula.
        ArrayList childBVS = (ArrayList) bvs.clone();   // The list of bound
                                    // variables that the internal formula will
                                    // be subject to.
        Formula form = null;        // The formula for this FOL formula.
        String id = null;           // Used for matching identifiers in the
                                    // bound variables list.
    }
    : OPEN_P "forall" OPEN_P (OPEN_P id=identifier
            {
                for (int i = 0; i < bvs.size(); ++i)
                {
                    if (((Variable) bvs.get(i)).getExternalName().equals(id))
                        throw new NestedBindingException();
                }
                Variable var = Variable.createNewBoundVar(id);
                localBVS.add(var);
                childBVS.add(var);
            }
        CLOSE_P)+ CLOSE_P form=formulaType[childBVS, others] CLOSE_P
        {
            FOLConstructor folc = (FOLConstructor) Symbol.putOrGet(
                                                FOLConstructor.class, "forall");
            f = FormulaFactory.getFormula(folc, new Object[] {localBVS, form});
        }
    | OPEN_P "for-some" OPEN_P (OPEN_P id=identifier
            {
                for (int i = 0; i < bvs.size(); ++i)
                {
                    if (((Variable) bvs.get(i)).getExternalName().equals(id))
                        throw new NestedBindingException();
                }
                Variable var = Variable.createNewBoundVar(id);
                localBVS.add(var);
                childBVS.add(var);
            }
        CLOSE_P)+ CLOSE_P form=formulaType[childBVS, others] CLOSE_P
        {
            FOLConstructor folc = (FOLConstructor) Symbol.putOrGet(
                                            FOLConstructor.class, "for-some");
            f = FormulaFactory.getFormula(folc, new Object[] {localBVS, form});
        }
    ;

/**
* Matches a predicate formula in the form of: <code>(<i>predicate_name
* terms</i>)</code>, where terms is one or more terms or variables.
* @param bvs the list of bound varibles so far.
* @param others the list of free varibles or constants so far.
* @throws NestedBindingException if a bound variable is used later as
* the bound variable in an FOLFormula, a class term, or an iota term.
* @return A Formula object corresponding to this predicate formula.
*/
predicateType [ArrayList bvs, HashMap others]
    returns [Formula f = null]
    throws NestedBindingException
    {
        List list = new ArrayList();    // The arguments for this predicate
                                        //   formula.
        Term t = null;                  // Any term type matched as an argument.
        String id = null;               // Any variable name matched as an
                                        //   argument.
    }
    : OPEN_P s:SYMBOL (( t=termType[bvs, others]
            { list.add(t); }
       ) | id=identifier
            {
                Variable bMatch = null;
                
                // Is the identifier in the list of bound variables?
                for (int i = 0; i < bvs.size(); ++i)
                {
                    if (((Variable) bvs.get(i)).getExternalName().equals(id))
                    {
                        bMatch = (Variable) bvs.get(i);
                        break;
                    }
                }
                if (bMatch != null)
                    list.add(bMatch);
                else
                {
                    if (this.inTarget)
                    {
                        // Is the identifier in the map of constants?
                        if (others.containsKey(id))
                            list.add(others.get(id));
                        else
                        {
                            Function newFunc = Function.createNewConstant(id);
                            list.add(newFunc);
                            others.put(id, newFunc);
                        }
                    }
                    else
                    {
                        // Is the identifier in the list of free variables?
                        Variable freeMatch = null;
                        if (others.containsKey(id))
                            list.add(others.get(id));
                        else
                        {
                            Variable newVar = Variable.createNewSequentVar(id);
                            list.add(newVar);
                            others.put(id, newVar);
                        }
                    }
                }        
            }
        )* CLOSE_P
        {
            PredicateConstructor ps;
            ps = (PredicateConstructor) Symbol.putOrGet(
                               PredicateConstructor.class, s.getText());
            f = FormulaFactory.getFormula(ps, new Object[] {list});
        }
    ;

/**
* Matches a term, which is either a class type, an iota type, or a
* function type.
* @param bvs the list of bound varibles so far.
* @param others the list of free varibles or constants so far.
* @throws NestedBindingException if a bound variable is used later as
* the bound variable in an FOLFormula, a class term, or an iota term.
* @return A Term object corresponding to this term.
*/
termType [ArrayList bvs, HashMap others]
    returns [ComplexTerm t = null]
    throws NestedBindingException
    : OPEN_P CLOSE_P
    | t=classType[bvs, others]
    | t=iotaType[bvs, others]
    | t=functionType[bvs, others]
    ;

/**
* Matches a class type, in the form of: <code>(the-class-of-all (
* <i>variable</i>) <i>formula</i>)</code>.
* @param bvs the list of bound varibles so far.
* @param others the list of free varibles or constants so far.
* @throws NestedBindingException if a bound variable is used later as
* the bound variable in an FOLFormula, a class term, or an iota term.
* @return A Term object corresponding to this class term.
*/
classType [ArrayList bvs, HashMap others]
    returns [ComplexTerm t = null]
    throws NestedBindingException
    {
        ArrayList childBVS = (ArrayList) bvs.clone();   // The list of bound
                                            //  variables that the internal
                                            //  formula will be subject to.
        Variable var = null;        // The bound variable for this class term.
        String id = null;           // The variable name matched as an argument.
        Formula f = null;           // The formula for this class term.
    }
    : OPEN_P "the-class-of-all" OPEN_P id=identifier
            {
                for (int i = 0; i < bvs.size(); ++i)
                {
                    if (((Variable) bvs.get(i)).getExternalName().equals(id))
                        throw new NestedBindingException();
                }
                var = Variable.createNewBoundVar(id);
                childBVS.add(var);
            }
        CLOSE_P f=formulaType[childBVS, others] CLOSE_P
        {
            TermConstructor tc = (TermConstructor) Symbol.putOrGet(
                                    TermConstructor.class, "the-class-of-all");
            t = TermFactory.getTerm(tc, new Object[] {var, f});
        }
    ;

/**
* Matches a class type, in the form of: <code>(the (
* <i>variable</i>) <i>formula</i>)</code>.
* @param bvs the list of bound varibles so far.
* @param others the list of free varibles or constants so far.
* @throws NestedBindingException if a bound variable is used later as
* the bound variable in an FOLFormula, a class term, or an iota term.
* @return A Term object corresponding to this iota term.
*/
iotaType [ArrayList bvs, HashMap others]
    returns [ComplexTerm t = null]
    throws NestedBindingException
    {
        ArrayList childBVS = (ArrayList) bvs.clone();   // The list of bound
                                            //  variables that the internal
                                            //  formula will be subject to.
        Variable var = null;        // The bound variable for this class term.
        String id = null;           // The variable name matched as an argument.
        Formula f = null;           // The formula for this class term.
    }
    : OPEN_P "the" OPEN_P id=identifier
            {
                for (int i = 0; i < bvs.size(); ++i)
                {
                    if (((Variable) bvs.get(i)).getExternalName().equals(id))
                        throw new NestedBindingException();
                }
                var = Variable.createNewBoundVar(id);
                childBVS.add(var);
            }
        CLOSE_P f=formulaType[childBVS, others] CLOSE_P
        {
            TermConstructor tc = (TermConstructor) Symbol.putOrGet(
                                                TermConstructor.class, "the");
            t = TermFactory.getTerm(tc, new Object[] {var, f});
        }
    ;

/**
* Matches a class type, in the form of: <code>(<i>function_name
* terms</i>)</code>, where terms is one or more terms or variables.
* @param bvs the list of bound varibles so far.
* @param others the list of free varibles or constants so far.
* @throws NestedBindingException if a bound variable is used later as
* the bound variable in an FOLFormula, a class term, or an iota term.
* @return A Term object corresponding to this function.
*/
functionType [ArrayList bvs, HashMap others]
    returns [ComplexTerm t = null]
    throws NestedBindingException
    {
        List list = new ArrayList();
        String id = null;
    }
    : OPEN_P s:SYMBOL (( t=termType[bvs, others]
            { list.add(t); }
       ) | id=identifier
            {
                Variable bMatch = null;
                
                // Is the identifier in the list of bound variables?
                for (int i = 0; i < bvs.size(); ++i)
                {
                    Variable temp = (Variable) bvs.get(i);
                    if (((Variable) bvs.get(i)).getExternalName().equals(id))
                    {
                        bMatch = (Variable) bvs.get(i);
                        break;
                    }
                }
                if (bMatch != null)
                    list.add(bMatch);
                else
                {
                    if (this.inTarget)
                    {
                        // Is the identifier in the map of constants?
                        if (others.containsKey(id))
                            list.add(others.get(id));
                        else
                        {
                            Function newFunc = Function.createNewConstant(id);
                            list.add(newFunc);
                            others.put(id, newFunc);
                        }
                    }
                    else
                    {
                        // Is the identifier in the list of free variables?
                        Variable freeMatch = null;
                        if (others.containsKey(id))
                            list.add(others.get(id));
                        else
                        {
                            Variable newVar = Variable.createNewSequentVar(id);
                            list.add(newVar);
                            others.put(id, newVar);
                        }
                    }
                }
            }
        )* CLOSE_P
        {
            FunctionConstructor fs;
            fs = (FunctionConstructor) Symbol.putOrGet(
                                        FunctionConstructor.class, s.getText());
            t = Function.createFunction(fs, list);
        }
    ;

/**
* Matches a string desctription in the form: <code>(string "
* <i>text</i>")</code>.
* @return a String of what's inside the quotes.
*/
stringType
    returns [String s = null]
    : OPEN_P "name" sl:STRING_LITERAL CLOSE_P
        { s = sl.getText(); }
    ;

/**
* Matches a format desctription in the form: <code>(format "
* <i>text</i>")</code>.
* @return a String of what's inside the quotes.
*/
formatType
    returns [String s = null]
    : OPEN_P "format" sl:STRING_LITERAL CLOSE_P
        { s = sl.getText(); }
    ;

/**
* Matches a format only element, which can be either <code>(
* format-only true)</code> or <code>(format-only false)</code>.
*/
formatOnlyType
    : OPEN_P "format-only" "true" CLOSE_P
        { this.formatOnly = true; }
    | OPEN_P "format-only" "false" CLOSE_P
        { this.formatOnly = false; }
    ;

/**
* Matches a file include element, which is in the form of <code>(
* include "<i>filename</i>")</code>.
* @return the filename that is between the quotes.
*/
fileIncludeType
    returns [String s = null]
    : OPEN_P "include" sl:STRING_LITERAL CLOSE_P
        { s = sl.getText(); }
    ;

/**
* Matches an identifier, which can be any reserved words as well as
* any valid identifier.  Used for allowing theorem names and other
* identifiers to be the same as the keywords.
* @todo why are these new Strings instead of literals?
* @return the String of what was matched.
*/
identifier
    returns [String id = null]
    : ( s:SYMBOL        { id = s.getText(); }
      | "and"           { id = "and"; }
      | "def-axiom"     { id = "def-axiom"; }
      | "def-lemma"     { id = "def-lemma"; }
      | "def-predicate" { id = "def-predicate"; }
      | "def-conjecture"    { id = "def-conjecture"; }
      | "def-term"      { id = "def-term"; }
      | "def-knowledge"   { id = "def-knowledge"; }
      | "false"         { id = "false"; }
      | "falsity"       { id = "falsity"; }
      | "format"        { id = "format"; }
      | "format-only"   { id = "format-only"; }
      | "iff"           { id = "iff"; }
      | "implies"       { id = "implies"; }
      | "include"       { id = "include"; }
      | "not"           { id = "not"; }
      | "or"            { id = "or"; }
      | "string"        { id = "string"; }
      | "identifier"        { id = "identifier"; }
      | "name"        { id = "name"; }
      | "true"          { id = "true"; }
      | "truth"         { id = "truth"; }
      )
    ;


/**
* A lexer generated by the <a href="http://www.antlr.org/">ANTLR</a>
* tools.  Matches a stream of characters, packaging them into tokens
* to be shipped off to a BitnotsParser.
* @author ANTLR
* @author <a href="mailto:walpet@bethel.edu">Pete Wall</a>
* @version 1.0
*/
class BitnotsScanner extends Lexer;

options
{
    k = 2;
    charVocabulary='\3'..'\377';
    filter = WS;
}

/**
* Matches a string literal, which is a double quote, followed by
* several characters that aren't a double quote, followed by another
* double quote.  Note that this will not allow for the '\' to be used
* to escape the double quote.
*/
STRING_LITERAL
    options
    {
        paraphrase = "a quoted string";
    }
    : '"'! (~('"'))* '"'!
    ;

/**
* Matches any valid symbol.
*/
SYMBOL: (('a'..'z')
         |('A'..'Z')
         |('0'..'9')
         |'-'
         |'_'
         |'='
         |'<'
         |'>'
         |'*'
         |'+'
         |'/'
         |'?'
         |':'
         |'|'
        )+
       ;

/**
* Matches an opening parenthesis.
*/
OPEN_P
    options
    {
        paraphrase = "an opening paren";
    }
    : '('
    ;

/**
* Matches a closing parenthesis.
*/
CLOSE_P
    options
    {
        paraphrase = "a closing paren";
    }
    : ')'
    ;

/**
* Matches a comment, and promptly ignores it.  They do not get passed
* to the parser
*/
COMMENT
    : ';' (~('\n'|'\r'))* ('\n'|'\r'('\n')?)
        {
            $setType(Token.SKIP);
            newline();
        }
    ;

/**
* Matches whitespace, which is also ignored and not passed to the
* parser.
*/
protected
WS
    : (' '|'\t'|'\f')
        { $setType(Token.SKIP); }
    ;

/**
* Matches newline characters.  They do not get passed to the parser.
*/
NEWLINE
    : ('\r' | '\n' | '\r' '\n')
        {
            $setType(Token.SKIP);
            newline();
        }
    ;
