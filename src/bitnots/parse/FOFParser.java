// $ANTLR 2.7.5 (20050128): "fofparse.g" -> "FOFParser.java"$

package bitnots.parse;

import bitnots.expressions.*;
import bitnots.theories.*;

import java.util.Collections;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;

import antlr.TokenBuffer;
import antlr.TokenStreamException;
import antlr.TokenStreamIOException;
import antlr.ANTLRException;
import antlr.LLkParser;
import antlr.Token;
import antlr.TokenStream;
import antlr.RecognitionException;
import antlr.NoViableAltException;
import antlr.MismatchedTokenException;
import antlr.SemanticException;
import antlr.ParserSharedInputState;
import antlr.collections.impl.BitSet;

/**
* A parser generated by the <a href="http://www.antlr.org/">ANTLR</a>
* tools.  When paired with a FOFScanner, matches files that contain
* definitions used to aid in proving any matched targets.
* @author <a href="mailto:walpet@bethel.edu">Pete Wall</a>
* @author ANTLR
* @version 1.0
*/
public class FOFParser extends antlr.LLkParser       implements FOFParserTokenTypes
 {

/**
* True if we are currently reading a conjecture element.  This is
* important because when we read a free variable inside a def-target,
* we turn it into a constant.  All other times, we turn it into a
* sequent variable.
*/
private boolean inTarget = false;

/**
* This determines whether the built-in version of equals will be used.
* If this is true, any predicates matched with "equal" as its name
* will be changed into "=", which is what bitnots uses.
*/
private boolean useBitnotsEquality;

protected FOFParser(TokenBuffer tokenBuf, int k) {
  super(tokenBuf,k);
  tokenNames = _tokenNames;
}

public FOFParser(TokenBuffer tokenBuf) {
  this(tokenBuf,3);
}

protected FOFParser(TokenStream lexer, int k) {
  super(lexer,k);
  tokenNames = _tokenNames;
}

public FOFParser(TokenStream lexer) {
  this(lexer,3);
}

public FOFParser(ParserSharedInputState state) {
  super(state,3);
  tokenNames = _tokenNames;
}

/**
* Matches a file, which consists of elements.  Those elements are to
* be put into a definitions HashMap.
* @param defs the HashMap to place definitions into.
* @throws NestedBindingException if a bound variable is used later as
* the bound variable in an FOLFormula, a class term, or an iota term.
*/
	public final void fofFile(
		HashMap defs, boolean enableBitnotsEquality
	) throws RecognitionException, TokenStreamException, NestedBindingException {
		
		
		this.useBitnotsEquality = enableBitnotsEquality;
		
		
		{
		int _cnt3=0;
		_loop3:
		do {
			if ((LA(1)==LITERAL_input_formula||LA(1)==LITERAL_include)) {
				fofInput(defs);
			}
			else {
				if ( _cnt3>=1 ) { break _loop3; } else {throw new NoViableAltException(LT(1), getFilename());}
			}
			
			_cnt3++;
		} while (true);
		}
		match(Token.EOF_TYPE);
	}
	
/**
* Matches an element, which can be a file include, or an input_formula
* definition.
* @param defs The HashMap to place definitions into.
* @throws NestedBindingException if a bound variable is used later as
* the bound variable in an FOLFormula, a class term, or an iota term.
*/
	public final void fofInput(
		HashMap defs
	) throws RecognitionException, TokenStreamException, NestedBindingException {
		
		
		String filename = null;
		
		
		switch ( LA(1)) {
		case LITERAL_input_formula:
		{
			inputFormula(defs);
			break;
		}
		case LITERAL_include:
		{
			filename=include();
			if ( inputState.guessing==0 ) {
				
				((ArrayList) defs.get("fileincludes")).add(filename);
				
			}
			break;
		}
		default:
		{
			throw new NoViableAltException(LT(1), getFilename());
		}
		}
	}
	
/**
* Matches an input_clause definition, which defines what conjectures
* we have to prove, and what axioms, hypotheses and other elements we
* have to help us with the proof.
* @param defs The HashMap to place definitions into.
* @throws NestedBindingException if a bound variable is used later as
* the bound variable in an FOLFormula, a class term, or an iota term.
*/
	public final void inputFormula(
		HashMap defs
	) throws RecognitionException, TokenStreamException, NestedBindingException {
		
		Token  name = null;
		
		ArrayList bvs = new ArrayList();
		HashMap others = new HashMap();
		Formula form = null;
		String inputType = null;
		
		
		match(LITERAL_input_formula);
		match(OPEN_P);
		name = LT(1);
		match(LOWER_WORD);
		match(COMMA);
		inputType=type();
		if ( inputState.guessing==0 ) {
			
			if (inputType.equals("conjecture"))
			this.inTarget = true;
			
		}
		match(COMMA);
		form=logicFormula(bvs, others);
		match(CLOSE_P);
		match(PERIOD);
		if ( inputState.guessing==0 ) {
			
			if (inputType.equals("axiom")
			|| inputType.equals("hypothesis"))
			{
			((HashSet) defs.get("axioms")).add(
			new Axiom(form, name.getText(), null));
			}
			else if (inputType.equals("conjecture"))
			{
			Formula form2 = FormulaFactory.getFormula(
			(PropositionalConstructor) Symbol.putOrGet(
			PropositionalConstructor.class, "not"),
			new Object[] {Collections.singletonList(form)});
			((ArrayList) defs.get("targets")).add(
			new Conjecture(form2, name.getText(), null));
			this.inTarget = false;
			}
			else
			{
			System.out.println("Something I didn't expect: " + inputType);
			}
			
		}
	}
	
/**
* Matches a file include element.
* @return the filename that is between the quotes.
*/
	public final String  include() throws RecognitionException, TokenStreamException {
		String filename = null;
		
		Token  f = null;
		
		match(LITERAL_include);
		match(OPEN_P);
		f = LT(1);
		match(QUOTED_STRING);
		{
		switch ( LA(1)) {
		case LOWER_WORD:
		case OPEN_B:
		{
			formulaSelection();
			break;
		}
		case CLOSE_P:
		{
			break;
		}
		default:
		{
			throw new NoViableAltException(LT(1), getFilename());
		}
		}
		}
		match(CLOSE_P);
		match(PERIOD);
		if ( inputState.guessing==0 ) {
			filename = f.getText();
		}
		return filename;
	}
	
/**
* Matches a type, which tells us the type of input_clause we matched.
* @return a String representation of the type.
*/
	public final String  type() throws RecognitionException, TokenStreamException {
		String s = null;
		
		
		String opt = null;
		
		
		switch ( LA(1)) {
		case LITERAL_axiom:
		case LITERAL_definition:
		case LITERAL_knowledge:
		case LITERAL_assumption:
		case LITERAL_hypothesis:
		case LITERAL_conjecture:
		case LITERAL_lemma:
		case LITERAL_theorem:
		case LITERAL_plain:
		case LITERAL_unknown:
		{
			s=userType();
			{
			switch ( LA(1)) {
			case DASH:
			{
				opt=optSourceType();
				break;
			}
			case COMMA:
			{
				break;
			}
			default:
			{
				throw new NoViableAltException(LT(1), getFilename());
			}
			}
			}
			if ( inputState.guessing==0 ) {
				
				if (opt != null)
				s = s.concat(opt);
				
			}
			break;
		}
		case LITERAL_derived:
		{
			s=sourceType();
			break;
		}
		default:
		{
			throw new NoViableAltException(LT(1), getFilename());
		}
		}
		return s;
	}
	
/**
* Matches a logic formula which can be either a literal formula, or a
* binary formula.
* @param bvs the list of bound varibles so far.
* @param others the list of free varibles or constants so far.
* @throws NestedBindingException if a bound variable is used later as
* the bound variable in an FOLFormula, a class term, or an iota term.
* @return the formula matched.
*/
	public final Formula  logicFormula(
		ArrayList bvs, HashMap others
	) throws RecognitionException, TokenStreamException, NestedBindingException {
		Formula form = null;
		
		
		String s = null;
		Formula form2 = null;
		ArrayList list = new ArrayList();
		
		
		form=literalFormula(bvs, others);
		{
		switch ( LA(1)) {
		case AND:
		case N_AND:
		case OR:
		case N_OR:
		case IFF:
		case XOR:
		case IMPLIES:
		case R_IMPLIES:
		{
			s=binaryConnective();
			form2=logicFormula(bvs, others);
			if ( inputState.guessing==0 ) {
				
				list.add(form);
				list.add(form2);
				
			}
			break;
		}
		case CLOSE_P:
		{
			break;
		}
		default:
		{
			throw new NoViableAltException(LT(1), getFilename());
		}
		}
		}
		if ( inputState.guessing==0 ) {
			
			if (s != null)
			{
			// We know that it is a binary formula
			if (s.equals("&"))  // AND
			{
			form = FormulaFactory.getFormula(
			(PropositionalConstructor) Symbol.putOrGet(
			PropositionalConstructor.class, "and"),
			new Object[] {list});
			}
			else if (s.equals("~&")) // NAND
			{
			Formula form3 = FormulaFactory.getFormula(
			(PropositionalConstructor) Symbol.putOrGet(
			PropositionalConstructor.class, "and"),
			new Object[] {list});
			form = FormulaFactory.getFormula(
			(PropositionalConstructor) Symbol.putOrGet(
			PropositionalConstructor.class, "not"),
			new Object[] {Collections.singletonList(form3)});
			}
			else if (s.equals("|")) // OR
			{
			form = FormulaFactory.getFormula(
			(PropositionalConstructor) Symbol.putOrGet(
			PropositionalConstructor.class, "or"),
			new Object[] {list});
			}
			else if (s.equals("~|")) // NAND
			{
			Formula form3 = FormulaFactory.getFormula(
			(PropositionalConstructor) Symbol.putOrGet(
			PropositionalConstructor.class, "or"),
			new Object[] {list});
			form = FormulaFactory.getFormula(
			(PropositionalConstructor) Symbol.putOrGet(
			PropositionalConstructor.class, "not"),
			new Object[] {Collections.singletonList(form3)});
			}
			else if (s.equals("<=>"))   // IFF
			{
			form = FormulaFactory.getFormula(
			(PropositionalConstructor) Symbol.putOrGet(
			PropositionalConstructor.class, "iff"),
			new Object[] {list});
			}
			else if (s.equals("<~>"))   // XOR
			{
			// (A OR B) AND (NOT (A AND B))
			Formula or = FormulaFactory.getFormula(
			(PropositionalConstructor) Symbol.putOrGet(
			PropositionalConstructor.class, "or"),
			new Object[] {list});
			Formula and = FormulaFactory.getFormula(
			(PropositionalConstructor) Symbol.putOrGet(
			PropositionalConstructor.class, "and"),
			new Object[] {list});
			Formula notAnd = FormulaFactory.getFormula(
			(PropositionalConstructor) Symbol.putOrGet(
			PropositionalConstructor.class, "not"),
			new Object[] {Collections.singletonList(and)});
			ArrayList orAndNotAnd = new ArrayList(2);
			orAndNotAnd.add(or);
			orAndNotAnd.add(notAnd);
			form = FormulaFactory.getFormula(
			(PropositionalConstructor) Symbol.putOrGet(
			PropositionalConstructor.class, "and"),
			new Object[] {orAndNotAnd});
			}
			else if (s.equals("=>"))    // IMPLIES
			{
			form = FormulaFactory.getFormula(
			(PropositionalConstructor) Symbol.putOrGet(
			PropositionalConstructor.class, "implies"),
			new Object[] {list});
			}
			else if (s.equals("<="))    // RIMPLIES
			{
			Collections.reverse(list);
			form = FormulaFactory.getFormula(
			(PropositionalConstructor) Symbol.putOrGet(
			PropositionalConstructor.class, "implies"),
			new Object[] {list});
			}
			}
			
		}
		return form;
	}
	
/**
* Matches a literal formula which can be either a quantified formula,
* a bracketed formula, a unary formula, or an atomic formula.
* @param bvs the list of bound varibles so far.
* @param others the list of free varibles or constants so far.
* @throws NestedBindingException if a bound variable is used later as
* the bound variable in an FOLFormula, a class term, or an iota term.
* @return the formula matched.
*/
	public final Formula  literalFormula(
		ArrayList bvs, HashMap others
	) throws RecognitionException, TokenStreamException, NestedBindingException {
		Formula form = null;
		
		
		switch ( LA(1)) {
		case QUANTIFIER:
		{
			form=quantifiedFormula(bvs, others);
			break;
		}
		case OPEN_P:
		{
			form=bracketedFormula(bvs, others);
			break;
		}
		case TILDE:
		{
			form=unaryFormula(bvs, others);
			break;
		}
		case LOWER_WORD:
		case LITERAL_true:
		case LITERAL_false:
		case LITERAL_equal:
		{
			form=atom(bvs, others);
			break;
		}
		default:
		{
			throw new NoViableAltException(LT(1), getFilename());
		}
		}
		return form;
	}
	
/**
* Matches a binary connective.
* @return the string of the connective matched.
*/
	public final String  binaryConnective() throws RecognitionException, TokenStreamException {
		String s = null;
		
		Token  a = null;
		Token  b = null;
		Token  c = null;
		Token  d = null;
		Token  e = null;
		Token  f = null;
		Token  g = null;
		Token  h = null;
		
		switch ( LA(1)) {
		case AND:
		{
			a = LT(1);
			match(AND);
			if ( inputState.guessing==0 ) {
				s = a.getText();
			}
			break;
		}
		case N_AND:
		{
			b = LT(1);
			match(N_AND);
			if ( inputState.guessing==0 ) {
				s = b.getText();
			}
			break;
		}
		case OR:
		{
			c = LT(1);
			match(OR);
			if ( inputState.guessing==0 ) {
				s = c.getText();
			}
			break;
		}
		case N_OR:
		{
			d = LT(1);
			match(N_OR);
			if ( inputState.guessing==0 ) {
				s = d.getText();
			}
			break;
		}
		case IFF:
		{
			e = LT(1);
			match(IFF);
			if ( inputState.guessing==0 ) {
				s = e.getText();
			}
			break;
		}
		case XOR:
		{
			f = LT(1);
			match(XOR);
			if ( inputState.guessing==0 ) {
				s = f.getText();
			}
			break;
		}
		case IMPLIES:
		{
			g = LT(1);
			match(IMPLIES);
			if ( inputState.guessing==0 ) {
				s = g.getText();
			}
			break;
		}
		case R_IMPLIES:
		{
			h = LT(1);
			match(R_IMPLIES);
			if ( inputState.guessing==0 ) {
				s = h.getText();
			}
			break;
		}
		default:
		{
			throw new NoViableAltException(LT(1), getFilename());
		}
		}
		return s;
	}
	
/**
* Matches a quantified formula using either "!" or "?" to correspond
* to forall and for-some, respectively.
* @param bvs the list of bound varibles so far.
* @param others the list of free varibles or constants so far.
* @throws NestedBindingException if a bound variable is used later as
* the bound variable in an FOLFormula, a class term, or an iota term.
* @return A Formula object corresponding to this first-order logic
* formula.
*/
	public final Formula  quantifiedFormula(
		ArrayList bvs, HashMap others
	) throws RecognitionException, TokenStreamException, NestedBindingException {
		Formula form = null;
		
		Token  q = null;
		
		ArrayList localBVS = new ArrayList();
		ArrayList childBVS = (ArrayList) bvs.clone();
		Formula f = null;
		String id = null;
		
		
		q = LT(1);
		match(QUANTIFIER);
		match(OPEN_B);
		id=qvariable();
		if ( inputState.guessing==0 ) {
			
			for (int i = 0; i < bvs.size(); ++i)
			{
			if (((Variable) bvs.get(i)).getExternalName().equals(id))
			throw new NestedBindingException();
			}
			Variable var = Variable.createNewBoundVar(id);
			localBVS.add(var);
			childBVS.add(var);
			
		}
		{
		_loop18:
		do {
			if ((LA(1)==COMMA)) {
				match(COMMA);
				id=qvariable();
				if ( inputState.guessing==0 ) {
					
					for (int i = 0; i < bvs.size(); ++i)
					{
					if (((Variable) bvs.get(i)).getExternalName().equals(id))
					throw new NestedBindingException();
					}
					Variable var = Variable.createNewBoundVar(id);
					localBVS.add(var);
					childBVS.add(var);
					
				}
			}
			else {
				break _loop18;
			}
			
		} while (true);
		}
		match(CLOSE_B);
		match(COLON);
		f=literalFormula(childBVS, others);
		if ( inputState.guessing==0 ) {
			
			if (q.getText().equals("!"))
			form = FormulaFactory.getFormula(
			(FOLConstructor) Symbol.putOrGet(
			FOLConstructor.class, "forall"),
			new Object[] {localBVS, f});
			else if (q.getText().equals("?"))
			form = FormulaFactory.getFormula(
			(FOLConstructor) Symbol.putOrGet(
			FOLConstructor.class, "for-some"),
			new Object[] {localBVS, f});
			
		}
		return form;
	}
	
/**
* Matches a formula enclosed in parentheses.
* @param bvs the list of bound varibles so far.
* @param others the list of free varibles or constants so far.
* @throws NestedBindingException if a bound variable is used later as
* the bound variable in an FOLFormula, a class term, or an iota term.
* @return the formula inside the parens.
*/
	public final Formula  bracketedFormula(
		ArrayList bvs, HashMap others
	) throws RecognitionException, TokenStreamException, NestedBindingException {
		Formula form = null;
		
		
		match(OPEN_P);
		form=logicFormula(bvs, others);
		match(CLOSE_P);
		return form;
	}
	
/**
* Matches a unary connective.
* @return the string of the connective matched.
*/
	public final String  unaryConnective() throws RecognitionException, TokenStreamException {
		String s = null;
		
		Token  a = null;
		
		a = LT(1);
		match(TILDE);
		if ( inputState.guessing==0 ) {
			s = a.getText();
		}
		return s;
	}
	
/**
* Matches a unary formula, which is a formula with a unary connective
* attached to the front.
* @param bvs the list of bound varibles so far.
* @param others the list of free varibles or constants so far.
* @throws NestedBindingException if a bound variable is used later as
* the bound variable in an FOLFormula, a class term, or an iota term.
* @return the unary formula matched.
*/
	public final Formula  unaryFormula(
		ArrayList bvs, HashMap others
	) throws RecognitionException, TokenStreamException, NestedBindingException {
		Formula form = null;
		
		
		String s = null;
		Formula f = null;
		
		
		s=unaryConnective();
		f=literalFormula(bvs, others);
		if ( inputState.guessing==0 ) {
			
			if (s.equals("~")) // NOT
			{
			form = FormulaFactory.getFormula(
			(PropositionalConstructor) Symbol.putOrGet(
			PropositionalConstructor.class, "not"),
			new Object[] {Collections.singletonList(f)});
			}
			
		}
		return form;
	}
	
/**
* Matches an atomic formula.  This can be "true" and "false", or a
* predicate, including the equals predicate.
* @param bvs the list of bound varibles so far.
* @param others the list of free varibles or constants so far.
* @return the formula matched.
*/
	public final Formula  atom(
		ArrayList bvs, HashMap others
	) throws RecognitionException, TokenStreamException {
		Formula form = null;
		
		
		Term t = null;
		ArrayList list = new ArrayList(2);
		String name = null;
		
		
		switch ( LA(1)) {
		case LITERAL_true:
		{
			match(LITERAL_true);
			if ( inputState.guessing==0 ) {
				
				LogicalConstructor ps = (LogicalConstructor) Symbol.putOrGet(
				LogicalConstructor.class, "truth");
				form = FormulaFactory.getFormula(ps, null);
				
			}
			break;
		}
		case LITERAL_false:
		{
			match(LITERAL_false);
			if ( inputState.guessing==0 ) {
				
				LogicalConstructor ps = (LogicalConstructor) Symbol.putOrGet(
				LogicalConstructor.class, "truth");
				form = FormulaFactory.getFormula(ps, null);
				
			}
			break;
		}
		case LITERAL_equal:
		{
			match(LITERAL_equal);
			match(OPEN_P);
			t=term(bvs, others);
			if ( inputState.guessing==0 ) {
				
				list.add(t);
				
			}
			match(COMMA);
			t=term(bvs, others);
			if ( inputState.guessing==0 ) {
				
				list.add(t);
				
			}
			match(CLOSE_P);
			if ( inputState.guessing==0 ) {
				
				name = "equals";
				if (this.useBitnotsEquality)
				name = "=";
				form = FormulaFactory.getFormula(
				(PredicateConstructor) Symbol.putOrGet(
				PredicateConstructor.class,
				name), new Object[] {list});
				
			}
			break;
		}
		default:
			if ((LA(1)==LOWER_WORD) && (_tokenSet_0.member(LA(2)))) {
				form=proposition(bvs, others);
			}
			else if ((LA(1)==LOWER_WORD) && (LA(2)==OPEN_P)) {
				form=predicate(bvs, others);
			}
		else {
			throw new NoViableAltException(LT(1), getFilename());
		}
		}
		return form;
	}
	
/**
* Matches a variable used in a quantified formula.  This variable is
* now bound and will throw exceptions if it's bound by another
* quantified formula.
* @return the identifier of the variable matched.
*/
	public final String  qvariable() throws RecognitionException, TokenStreamException {
		String var = null;
		
		
		switch ( LA(1)) {
		case UPPER_WORD:
		{
			var=typedVariable();
			break;
		}
		case NUMBER:
		{
			match(NUMBER);
			match(COLON);
			var=typedVariable();
			break;
		}
		default:
		{
			throw new NoViableAltException(LT(1), getFilename());
		}
		}
		return var;
	}
	
/**
* Matches a variable with an optional type.  Typing is not implemented
* in this version of the parser.
* @return the identifier of the variable matched.
*/
	public final String  typedVariable() throws RecognitionException, TokenStreamException {
		String var = null;
		
		Token  a = null;
		Token  b = null;
		
		if ((LA(1)==UPPER_WORD) && (LA(2)==COMMA||LA(2)==CLOSE_B)) {
			a = LT(1);
			match(UPPER_WORD);
			if ( inputState.guessing==0 ) {
				var = a.getText();
			}
		}
		else if ((LA(1)==UPPER_WORD) && (LA(2)==COLON)) {
			b = LT(1);
			match(UPPER_WORD);
			match(COLON);
			match(LOWER_WORD);
			if ( inputState.guessing==0 ) {
				var = b.getText();
			}
		}
		else {
			throw new NoViableAltException(LT(1), getFilename());
		}
		
		return var;
	}
	
/**
* Matches a user type.
* @return the String representation of the user type.
*/
	public final String  userType() throws RecognitionException, TokenStreamException {
		String type = null;
		
		
		switch ( LA(1)) {
		case LITERAL_axiom:
		{
			match(LITERAL_axiom);
			if ( inputState.guessing==0 ) {
				type = new String("axiom");
			}
			break;
		}
		case LITERAL_definition:
		{
			match(LITERAL_definition);
			if ( inputState.guessing==0 ) {
				type = new String("definition");
			}
			break;
		}
		case LITERAL_knowledge:
		{
			match(LITERAL_knowledge);
			if ( inputState.guessing==0 ) {
				type = new String("knowledge");
			}
			break;
		}
		case LITERAL_assumption:
		{
			match(LITERAL_assumption);
			if ( inputState.guessing==0 ) {
				type = new String("assumption");
			}
			break;
		}
		case LITERAL_hypothesis:
		{
			match(LITERAL_hypothesis);
			if ( inputState.guessing==0 ) {
				type = new String("hypothesis");
			}
			break;
		}
		case LITERAL_conjecture:
		{
			match(LITERAL_conjecture);
			if ( inputState.guessing==0 ) {
				type = new String("conjecture");
			}
			break;
		}
		case LITERAL_lemma:
		{
			match(LITERAL_lemma);
			if ( inputState.guessing==0 ) {
				type = new String("lemma");
			}
			break;
		}
		case LITERAL_theorem:
		{
			match(LITERAL_theorem);
			if ( inputState.guessing==0 ) {
				type = new String("theorem");
			}
			break;
		}
		case LITERAL_plain:
		{
			match(LITERAL_plain);
			if ( inputState.guessing==0 ) {
				type = new String("plain");
			}
			break;
		}
		case LITERAL_unknown:
		{
			match(LITERAL_unknown);
			if ( inputState.guessing==0 ) {
				type = new String("unknown");
			}
			break;
		}
		default:
		{
			throw new NoViableAltException(LT(1), getFilename());
		}
		}
		return type;
	}
	
/**
* Matches an optional source type.
* @return a String representation of the optional source type.
*/
	public final String  optSourceType() throws RecognitionException, TokenStreamException {
		String type = null;
		
		
		match(DASH);
		type=sourceType();
		if ( inputState.guessing==0 ) {
			
			type = "-".concat(type);
			
		}
		return type;
	}
	
/**
* Matches a source type.
* @return the String representation of the source type.
*/
	public final String  sourceType() throws RecognitionException, TokenStreamException {
		String type = null;
		
		
		match(LITERAL_derived);
		if ( inputState.guessing==0 ) {
			type = new String("derived");
		}
		return type;
	}
	
/**
* Matches a term, which is either a function or a variable.
* @param bvs the list of bound varibles so far.
* @param others the list of free varibles or constants so far.
* @return the term matched.
*/
	public final Term  term(
		ArrayList bvs, HashMap others
	) throws RecognitionException, TokenStreamException {
		Term t = null;
		
		
		switch ( LA(1)) {
		case LOWER_WORD:
		case NUMBER:
		case QUOTED_STRING:
		{
			t=function(bvs, others);
			break;
		}
		case UPPER_WORD:
		{
			t=variable(bvs, others);
			break;
		}
		default:
		{
			throw new NoViableAltException(LT(1), getFilename());
		}
		}
		return t;
	}
	
/**
* Matches a proposition, which is simply a lower-case word.
* @param bvs the list of bound varibles so far.
* @param others the list of free varibles or constants so far.
* @return the formula representing this proposition.
*/
	public final Formula  proposition(
		ArrayList bvs, HashMap others
	) throws RecognitionException, TokenStreamException {
		Formula form = null;
		
		Token  a = null;
		
		a = LT(1);
		match(LOWER_WORD);
		if ( inputState.guessing==0 ) {
			
			form = FormulaFactory.getFormula(
			(PredicateConstructor) Symbol.putOrGet(
			PredicateConstructor.class, a.getText()),
			new Object[] {Collections.EMPTY_LIST});
			
		}
		return form;
	}
	
/**
* Matches a predicate.
* @param bvs the list of bound varibles so far.
* @param others the list of free varibles or constants so far.
* @return the formula representing this predicate.
*/
	public final Formula  predicate(
		ArrayList bvs, HashMap others
	) throws RecognitionException, TokenStreamException {
		Formula form = null;
		
		Token  s = null;
		
		ArrayList list = null;
		
		
		s = LT(1);
		match(LOWER_WORD);
		match(OPEN_P);
		list=arguments(bvs, others);
		match(CLOSE_P);
		if ( inputState.guessing==0 ) {
			
			String name = s.getText();
			form = FormulaFactory.getFormula(
			(PredicateConstructor) Symbol.putOrGet(
			PredicateConstructor.class,
			name), new Object[] {list});
			
		}
		return form;
	}
	
/**
* Matches a list of arguments, which is a comma-separated list of
* terms.
* @param bvs the list of bound varibles so far.
* @param others the list of free varibles or constants so far.
* @return the list of terms.
*/
	public final ArrayList  arguments(
		ArrayList bvs, HashMap others
	) throws RecognitionException, TokenStreamException {
		ArrayList list = new ArrayList(1);
		
		
		Term t = null;
		
		
		t=term(bvs, others);
		if ( inputState.guessing==0 ) {
			list.add(t);
		}
		{
		_loop34:
		do {
			if ((LA(1)==COMMA)) {
				match(COMMA);
				t=term(bvs, others);
				if ( inputState.guessing==0 ) {
					list.add(t);
				}
			}
			else {
				break _loop34;
			}
			
		} while (true);
		}
		return list;
	}
	
/**
* Matches a function, which can be a simple constant.
* @param bvs the list of bound varibles so far.
* @param others the list of free varibles or constants so far.
* @return the term representing this function.
*/
	public final Term  function(
		ArrayList bvs, HashMap others
	) throws RecognitionException, TokenStreamException {
		Term t = null;
		
		Token  s = null;
		
		ArrayList list = null;
		
		
		if ((LA(1)==LOWER_WORD||LA(1)==NUMBER||LA(1)==QUOTED_STRING) && (LA(2)==COMMA||LA(2)==CLOSE_P)) {
			t=constant(bvs, others);
		}
		else if ((LA(1)==LOWER_WORD) && (LA(2)==OPEN_P)) {
			s = LT(1);
			match(LOWER_WORD);
			match(OPEN_P);
			list=arguments(bvs, others);
			match(CLOSE_P);
			if ( inputState.guessing==0 ) {
				
				t = Function.createFunction(
				(FunctionConstructor) Symbol.putOrGet(
				FunctionConstructor.class, s.getText()), list);
				
			}
		}
		else {
			throw new NoViableAltException(LT(1), getFilename());
		}
		
		return t;
	}
	
/**
* Matches a variable, which is simple an upper-case word.
* @param bvs the list of bound varibles so far.
* @param others the list of free varibles or constants so far.
* @return a variable with the matched name.  If we've seen that
* variable before, use that object instead of making a new one.
*/
	public final Term  variable(
		ArrayList bvs, HashMap others
	) throws RecognitionException, TokenStreamException {
		Term t = null;
		
		Token  a = null;
		
		a = LT(1);
		match(UPPER_WORD);
		if ( inputState.guessing==0 ) {
			
			String name = a.getText();
			Variable bMatch = null;
			
			// Is the identifier in the list of bound variables?
			for (int i = 0; i < bvs.size(); ++i)
			{
			Variable temp = (Variable) bvs.get(i);
			if (((Variable) bvs.get(i)).getExternalName().equals(name))
			{
			bMatch = (Variable) bvs.get(i);
			break;
			}
			}
			if (bMatch != null)
			t = bMatch;
			else
			{
			if (this.inTarget)
			{
			// Is the identifier in the map of constants?
			if (others.containsKey(name))
			t = (Term) others.get(name);
			else
			t = Function.createNewConstant(name);
			}
			else
			{
			// Is the identifier in the list of free variables?
			Variable freeMatch = null;
			if (others.containsKey(name))
			t = (Term) others.get(name);
			else
			t = Variable.createNewSequentVar(name);
			}
			}
			
		}
		return t;
	}
	
/**
* Matches a constant, which can be a lower-case word, a number or a
* quoted string.
* @param bvs the list of bound varibles so far.
* @param others the list of free varibles or constants so far.
* @return the function representing this constant.
*/
	public final Term  constant(
		ArrayList bvs, HashMap others
	) throws RecognitionException, TokenStreamException {
		Term t = null;
		
		Token  a = null;
		Token  b = null;
		Token  c = null;
		
		String name = null;
		
		
		{
		switch ( LA(1)) {
		case LOWER_WORD:
		{
			a = LT(1);
			match(LOWER_WORD);
			if ( inputState.guessing==0 ) {
				name = a.getText();
			}
			break;
		}
		case NUMBER:
		{
			b = LT(1);
			match(NUMBER);
			if ( inputState.guessing==0 ) {
				name = b.getText();
			}
			break;
		}
		case QUOTED_STRING:
		{
			c = LT(1);
			match(QUOTED_STRING);
			if ( inputState.guessing==0 ) {
				name = c.getText();
			}
			break;
		}
		default:
		{
			throw new NoViableAltException(LT(1), getFilename());
		}
		}
		}
		if ( inputState.guessing==0 ) {
			
			Variable bMatch = null;
			
			// Is the identifier in the list of bound variables?
			for (int i = 0; i < bvs.size(); ++i)
			{
			Variable temp = (Variable) bvs.get(i);
			if (((Variable) bvs.get(i)).getExternalName().equals(name))
			{
			bMatch = (Variable) bvs.get(i);
			break;
			}
			}
			if (bMatch != null)
			t = bMatch;
			else
			{
			if (this.inTarget)
			{
			// Is the identifier in the map of constants?
			if (others.containsKey(name))
			t = (Term) others.get(name);
			else
			t = Function.createNewConstant(name);
			}
			else
			{
			// Is the identifier in the list of free variables?
			Variable freeMatch = null;
			if (others.containsKey(name))
			t = (Term) others.get(name);
			else
			t = Variable.createNewSequentVar(name);
			}
			}
			
		}
		return t;
	}
	
/**
* Matches a formula selection in the file include.  Currently this is
* not being used.
*/
	public final void formulaSelection() throws RecognitionException, TokenStreamException {
		
		
		switch ( LA(1)) {
		case LOWER_WORD:
		{
			match(LOWER_WORD);
			break;
		}
		case OPEN_B:
		{
			match(OPEN_B);
			match(LOWER_WORD);
			{
			int _cnt44=0;
			_loop44:
			do {
				if ((LA(1)==COMMA)) {
					match(COMMA);
					match(LOWER_WORD);
				}
				else {
					if ( _cnt44>=1 ) { break _loop44; } else {throw new NoViableAltException(LT(1), getFilename());}
				}
				
				_cnt44++;
			} while (true);
			}
			match(CLOSE_B);
			break;
		}
		default:
		{
			throw new NoViableAltException(LT(1), getFilename());
		}
		}
	}
	
	
	public static final String[] _tokenNames = {
		"<0>",
		"EOF",
		"<2>",
		"NULL_TREE_LOOKAHEAD",
		"\"input_formula\"",
		"an opening paren",
		"LOWER_WORD",
		"COMMA",
		"a closing paren",
		"PERIOD",
		"QUANTIFIER",
		"an opening bracket",
		"a closing bracket",
		"COLON",
		"NUMBER",
		"UPPER_WORD",
		"AND",
		"N_AND",
		"OR",
		"N_OR",
		"IFF",
		"XOR",
		"IMPLIES",
		"R_IMPLIES",
		"TILDE",
		"DASH",
		"\"axiom\"",
		"\"definition\"",
		"\"knowledge\"",
		"\"assumption\"",
		"\"hypothesis\"",
		"\"conjecture\"",
		"\"lemma\"",
		"\"theorem\"",
		"\"plain\"",
		"\"unknown\"",
		"\"derived\"",
		"\"true\"",
		"\"false\"",
		"\"equal\"",
		"a quoted string",
		"\"include\"",
		"UNDERSCORE",
		"COMMENT",
		"WS",
		"NEWLINE"
	};
	
	private static final long[] mk_tokenSet_0() {
		long[] data = { 16711936L, 0L};
		return data;
	}
	public static final BitSet _tokenSet_0 = new BitSet(mk_tokenSet_0());
	
	}
