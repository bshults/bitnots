header {
package bitnots.parse;

import bitnots.expressions.*;
import bitnots.theories.*;

import java.util.Collections;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
}

/**
* A parser generated by the <a href="http://www.antlr.org/">ANTLR</a>
* tools.  When paired with a FOFScanner, matches files that contain
* definitions used to aid in proving any matched targets.
* @author <a href="mailto:walpet@bethel.edu">Pete Wall</a>
* @author ANTLR
* @version 1.0
*/
class FOFParser extends Parser;
options
{
    k = 3;
    defaultErrorHandler=false;
}

{
/**
* True if we are currently reading a conjecture element.  This is
* important because when we read a free variable inside a def-target,
* we turn it into a constant.  All other times, we turn it into a
* sequent variable.
*/
private boolean inTarget = false;

/**
* This determines whether the built-in version of equals will be used.
* If this is true, any predicates matched with "equal" as its name
* will be changed into "=", which is what bitnots uses.
*/
private boolean useBitnotsEquality;
}

/**
* Matches a file, which consists of elements.  Those elements are to
* be put into a definitions HashMap.
* @param defs the HashMap to place definitions into.
* @throws NestedBindingException if a bound variable is used later as
* the bound variable in an FOLFormula, a class term, or an iota term.
*/
fofFile [HashMap defs, boolean enableBitnotsEquality]
    throws NestedBindingException
    {
        this.useBitnotsEquality = enableBitnotsEquality;
    }
    : (fofInput[defs])+ EOF
    ;

/**
* Matches an element, which can be a file include, or an input_formula
* definition.
* @param defs The HashMap to place definitions into.
* @throws NestedBindingException if a bound variable is used later as
* the bound variable in an FOLFormula, a class term, or an iota term.
*/
fofInput [HashMap defs]
    throws NestedBindingException
    {
        String filename = null;
    }
    : inputFormula[defs]
    | filename=include
        {
            ((ArrayList) defs.get("fileincludes")).add(filename);
        }
    ;

/**
* Matches an input_clause definition, which defines what conjectures
* we have to prove, and what axioms, hypotheses and other elements we
* have to help us with the proof.
* @param defs The HashMap to place definitions into.
* @throws NestedBindingException if a bound variable is used later as
* the bound variable in an FOLFormula, a class term, or an iota term.
*/
inputFormula [HashMap defs]
    throws NestedBindingException
    {
        ArrayList bvs = new ArrayList();
        HashMap others = new HashMap();
        Formula form = null;
        String inputType = null;
    }
    : "input_formula" OPEN_P name:LOWER_WORD COMMA inputType=type
            {
                if (inputType.equals("conjecture"))
                    this.inTarget = true;
            }
        COMMA form=logicFormula[bvs, others] CLOSE_P PERIOD
        {
            if (inputType.equals("axiom")
             || inputType.equals("hypothesis"))
            {
                ((HashSet) defs.get("axioms")).add(
                        new Axiom(form, name.getText(), null));
            }
            else if (inputType.equals("conjecture"))
            {
                Formula form2 = FormulaFactory.getFormula(
                    (PropositionalConstructor) Symbol.putOrGet(
                    PropositionalConstructor.class, "not"),
                    new Object[] {Collections.singletonList(form)});
                ((ArrayList) defs.get("targets")).add(
                        new Conjecture(form2, name.getText(), null));
                this.inTarget = false;
            }
            else
            {
                System.out.println("Something I didn't expect: " + inputType);
            }
        }
    ;

/**
* Matches a logic formula which can be either a literal formula, or a
* binary formula.
* @param bvs the list of bound varibles so far.
* @param others the list of free varibles or constants so far.
* @throws NestedBindingException if a bound variable is used later as
* the bound variable in an FOLFormula, a class term, or an iota term.
* @return the formula matched.
*/
logicFormula [ArrayList bvs, HashMap others]
    returns [Formula form = null]
    throws NestedBindingException
    {
        String s = null;
        Formula form2 = null;
        ArrayList list = new ArrayList();
    }
    : form=literalFormula[bvs, others] (s=binaryConnective form2=logicFormula[bvs, others]
            {
                list.add(form);
                list.add(form2);
            }
        )?
        {
            if (s != null)
            {
                // We know that it is a binary formula
                if (s.equals("&"))  // AND
                {
                    form = FormulaFactory.getFormula(
                                    (PropositionalConstructor) Symbol.putOrGet(
                                    PropositionalConstructor.class, "and"),
                                    new Object[] {list});
                }
                else if (s.equals("~&")) // NAND
                {
                    Formula form3 = FormulaFactory.getFormula(
                                    (PropositionalConstructor) Symbol.putOrGet(
                                    PropositionalConstructor.class, "and"),
                                    new Object[] {list});
                    form = FormulaFactory.getFormula(
                            (PropositionalConstructor) Symbol.putOrGet(
                            PropositionalConstructor.class, "not"),
                            new Object[] {Collections.singletonList(form3)});
                }
                else if (s.equals("|")) // OR
                {
                    form = FormulaFactory.getFormula(
                                    (PropositionalConstructor) Symbol.putOrGet(
                                    PropositionalConstructor.class, "or"),
                                    new Object[] {list});
                }
                else if (s.equals("~|")) // NAND
                {
                    Formula form3 = FormulaFactory.getFormula(
                                    (PropositionalConstructor) Symbol.putOrGet(
                                    PropositionalConstructor.class, "or"),
                                    new Object[] {list});
                    form = FormulaFactory.getFormula(
                            (PropositionalConstructor) Symbol.putOrGet(
                            PropositionalConstructor.class, "not"),
                            new Object[] {Collections.singletonList(form3)});
                }
                else if (s.equals("<=>"))   // IFF
                {
                    form = FormulaFactory.getFormula(
                                    (PropositionalConstructor) Symbol.putOrGet(
                                    PropositionalConstructor.class, "iff"),
                                    new Object[] {list});
                }
                else if (s.equals("<~>"))   // XOR
                {
                    // (A OR B) AND (NOT (A AND B))
                    Formula or = FormulaFactory.getFormula(
                                    (PropositionalConstructor) Symbol.putOrGet(
                                    PropositionalConstructor.class, "or"),
                                    new Object[] {list});
                    Formula and = FormulaFactory.getFormula(
                                    (PropositionalConstructor) Symbol.putOrGet(
                                    PropositionalConstructor.class, "and"),
                                    new Object[] {list});
                    Formula notAnd = FormulaFactory.getFormula(
                            (PropositionalConstructor) Symbol.putOrGet(
                            PropositionalConstructor.class, "not"),
                            new Object[] {Collections.singletonList(and)});
                    ArrayList orAndNotAnd = new ArrayList(2);
                    orAndNotAnd.add(or);
                    orAndNotAnd.add(notAnd);
                    form = FormulaFactory.getFormula(
                                    (PropositionalConstructor) Symbol.putOrGet(
                                    PropositionalConstructor.class, "and"),
                                    new Object[] {orAndNotAnd});
                }
                else if (s.equals("=>"))    // IMPLIES
                {
                    form = FormulaFactory.getFormula(
                                    (PropositionalConstructor) Symbol.putOrGet(
                                    PropositionalConstructor.class, "implies"),
                                    new Object[] {list});
                }
                else if (s.equals("<="))    // RIMPLIES
                {
                    Collections.reverse(list);
                    form = FormulaFactory.getFormula(
                                    (PropositionalConstructor) Symbol.putOrGet(
                                    PropositionalConstructor.class, "implies"),
                                    new Object[] {list});
                }
            }
        }
    ;

/**
* Matches a literal formula which can be either a quantified formula,
* a bracketed formula, a unary formula, or an atomic formula.
* @param bvs the list of bound varibles so far.
* @param others the list of free varibles or constants so far.
* @throws NestedBindingException if a bound variable is used later as
* the bound variable in an FOLFormula, a class term, or an iota term.
* @return the formula matched.
*/
literalFormula [ArrayList bvs, HashMap others]
    returns [Formula form = null]
    throws NestedBindingException
    : (QUANTIFIER) => form=quantifiedFormula[bvs, others]
    | (OPEN_P) => form=bracketedFormula[bvs, others]
    | (unaryConnective) => form=unaryFormula[bvs, others]
    | form=atom[bvs, others]
    ;

/**
* Matches a formula enclosed in parentheses.
* @param bvs the list of bound varibles so far.
* @param others the list of free varibles or constants so far.
* @throws NestedBindingException if a bound variable is used later as
* the bound variable in an FOLFormula, a class term, or an iota term.
* @return the formula inside the parens.
*/
bracketedFormula [ArrayList bvs, HashMap others]
    returns [Formula form = null]
    throws NestedBindingException
    : OPEN_P form=logicFormula[bvs, others] CLOSE_P
    ;

/**
* Matches a quantified formula using either "!" or "?" to correspond
* to forall and for-some, respectively.
* @param bvs the list of bound varibles so far.
* @param others the list of free varibles or constants so far.
* @throws NestedBindingException if a bound variable is used later as
* the bound variable in an FOLFormula, a class term, or an iota term.
* @return A Formula object corresponding to this first-order logic
* formula.
*/
quantifiedFormula [ArrayList bvs, HashMap others]
    returns [Formula form = null]
    throws NestedBindingException
    {
        ArrayList localBVS = new ArrayList();
        ArrayList childBVS = (ArrayList) bvs.clone();
        Formula f = null;
        String id = null;
    }
    : q:QUANTIFIER OPEN_B id=qvariable
            {
                for (int i = 0; i < bvs.size(); ++i)
                {
                    if (((Variable) bvs.get(i)).getExternalName().equals(id))
                        throw new NestedBindingException();
                }
                Variable var = Variable.createNewBoundVar(id);
                localBVS.add(var);
                childBVS.add(var);
            }
        (COMMA id=qvariable
            {
                for (int i = 0; i < bvs.size(); ++i)
                {
                    if (((Variable) bvs.get(i)).getExternalName().equals(id))
                        throw new NestedBindingException();
                }
                Variable var = Variable.createNewBoundVar(id);
                localBVS.add(var);
                childBVS.add(var);
            }
        )* CLOSE_B COLON f=literalFormula[childBVS, others]
        {
            if (q.getText().equals("!"))
                form = FormulaFactory.getFormula(
                                (FOLConstructor) Symbol.putOrGet(
                                FOLConstructor.class, "forall"),
                                new Object[] {localBVS, f});
            else if (q.getText().equals("?"))
                form = FormulaFactory.getFormula(
                                (FOLConstructor) Symbol.putOrGet(
                                FOLConstructor.class, "for-some"),
                                new Object[] {localBVS, f});
        }
    ;

/**
* Matches a variable used in a quantified formula.  This variable is
* now bound and will throw exceptions if it's bound by another
* quantified formula.
* @return the identifier of the variable matched.
*/
qvariable
    returns [String var = null]
    : var=typedVariable
    | NUMBER COLON var=typedVariable
    ;

/**
* Matches a variable with an optional type.  Typing is not implemented
* in this version of the parser.
* @return the identifier of the variable matched.
*/
typedVariable
    returns [String var = null]
    : a:UPPER_WORD
        { var = a.getText(); }
    | b:UPPER_WORD COLON LOWER_WORD
        { var = b.getText(); }
    ;

/**
* Matches a unary formula, which is a formula with a unary connective
* attached to the front.
* @param bvs the list of bound varibles so far.
* @param others the list of free varibles or constants so far.
* @throws NestedBindingException if a bound variable is used later as
* the bound variable in an FOLFormula, a class term, or an iota term.
* @return the unary formula matched.
*/
unaryFormula [ArrayList bvs, HashMap others]
    returns [Formula form = null]
    throws NestedBindingException
    {
        String s = null;
        Formula f = null;
    }
    : s=unaryConnective f=literalFormula[bvs, others]
        {
            if (s.equals("~")) // NOT
            {
                form = FormulaFactory.getFormula(
                                (PropositionalConstructor) Symbol.putOrGet(
                                PropositionalConstructor.class, "not"),
                                new Object[] {Collections.singletonList(f)});
            }
        }
    ;

/**
* Matches a binary connective.
* @return the string of the connective matched.
*/
binaryConnective
    returns [String s = null]
    : a:AND                     { s = a.getText(); }
    | b:N_AND                   { s = b.getText(); }
    | c:OR                      { s = c.getText(); }
    | d:N_OR                    { s = d.getText(); }
    | e:IFF                     { s = e.getText(); }
    | f:XOR                     { s = f.getText(); }
    | g:IMPLIES                 { s = g.getText(); }
    | h:R_IMPLIES               { s = h.getText(); }
    ;

/**
* Matches a unary connective.
* @return the string of the connective matched.
*/
unaryConnective
    returns [String s = null]
    : a:TILDE                   { s = a.getText(); }
    ;

/**
* Matches a type, which tells us the type of input_clause we matched.
* @return a String representation of the type.
*/
type
    returns [String s = null]
    {
        String opt = null;
    }
    : s=userType (opt=optSourceType)?
        {
            if (opt != null)
                s = s.concat(opt);
        }
    | s=sourceType
    ;

/**
* Matches an optional source type.
* @return a String representation of the optional source type.
*/
optSourceType
    returns [String type = null]
    : DASH type=sourceType
        {
            type = "-".concat(type);
        }
    ;

/**
* Matches a user type.
* @return the String representation of the user type.
*/
userType
    returns [String type = null]
    : "axiom"               { type = new String("axiom"); }
    | "definition"          { type = new String("definition"); }
    | "knowledge"           { type = new String("knowledge"); }
    | "assumption"          { type = new String("assumption"); }
    | "hypothesis"          { type = new String("hypothesis"); }
    | "conjecture"          { type = new String("conjecture"); }
    | "lemma"               { type = new String("lemma"); }
    | "theorem"             { type = new String("theorem"); }
    | "plain"               { type = new String("plain"); }
    | "unknown"             { type = new String("unknown"); }
    ;

/**
* Matches a source type.
* @return the String representation of the source type.
*/
sourceType
    returns [String type = null]
    : "derived"             { type = new String("derived"); }
    ;

/**
* Matches an atomic formula.  This can be "true" and "false", or a
* predicate, including the equals predicate.
* @param bvs the list of bound varibles so far.
* @param others the list of free varibles or constants so far.
* @return the formula matched.
*/
atom [ArrayList bvs, HashMap others]
    returns [Formula form = null]
    {
        Term t = null;
        ArrayList list = new ArrayList(2);
        String name = null;
    }
    : "true"
        {
            LogicalConstructor ps = (LogicalConstructor) Symbol.putOrGet(
                                            LogicalConstructor.class, "truth");
            form = FormulaFactory.getFormula(ps, null);
        }
    | "false"
        {
            LogicalConstructor ps = (LogicalConstructor) Symbol.putOrGet(
                                            LogicalConstructor.class, "truth");
            form = FormulaFactory.getFormula(ps, null);
        }
    | "equal" OPEN_P t=term[bvs, others]
            {
                list.add(t);
            }
        COMMA t=term[bvs, others]
            {
                list.add(t);
            }
        CLOSE_P
        {
            name = "equals";
            if (this.useBitnotsEquality)
                name = "=";
            form = FormulaFactory.getFormula(
                            (PredicateConstructor) Symbol.putOrGet(
                            PredicateConstructor.class,
                             name), new Object[] {list});
        }
    | form=proposition[bvs, others]
    | form=predicate[bvs, others]
    ;

/**
* Matches a proposition, which is simply a lower-case word.
* @param bvs the list of bound varibles so far.
* @param others the list of free varibles or constants so far.
* @return the formula representing this proposition.
*/
proposition [ArrayList bvs, HashMap others]
    returns [Formula form = null]
    : a:LOWER_WORD
        {
            form = FormulaFactory.getFormula(
                            (PredicateConstructor) Symbol.putOrGet(
                            PredicateConstructor.class, a.getText()),
                            new Object[] {Collections.EMPTY_LIST});
        }
    ;

/**
* Matches a predicate.
* @param bvs the list of bound varibles so far.
* @param others the list of free varibles or constants so far.
* @return the formula representing this predicate.
*/
predicate [ArrayList bvs, HashMap others]
    returns [Formula form = null]
    {
        ArrayList list = null;
    }
    : s:LOWER_WORD OPEN_P list=arguments[bvs, others] CLOSE_P
        {
            String name = s.getText();
            form = FormulaFactory.getFormula(
                            (PredicateConstructor) Symbol.putOrGet(
                            PredicateConstructor.class,
                            name), new Object[] {list});
        }
    ;

/**
* Matches a list of arguments, which is a comma-separated list of
* terms.
* @param bvs the list of bound varibles so far.
* @param others the list of free varibles or constants so far.
* @return the list of terms.
*/
arguments [ArrayList bvs, HashMap others]
    returns [ArrayList list = new ArrayList(1)]
    {
        Term t = null;
    }
    : t=term[bvs, others]
            { list.add(t); }
        (COMMA t=term[bvs, others]
            { list.add(t); }
        )*
    ;

/**
* Matches a term, which is either a function or a variable.
* @param bvs the list of bound varibles so far.
* @param others the list of free varibles or constants so far.
* @return the term matched.
*/
term [ArrayList bvs, HashMap others]
    returns [Term t = null]
    : t=function[bvs, others]
    | t=variable[bvs, others]
    ;

/**
* Matches a function, which can be a simple constant.
* @param bvs the list of bound varibles so far.
* @param others the list of free varibles or constants so far.
* @return the term representing this function.
*/
function [ArrayList bvs, HashMap others]
    returns [Term t = null]
    {
        ArrayList list = null;
    }
    : t=constant[bvs, others]
    | s:LOWER_WORD OPEN_P list=arguments[bvs, others] CLOSE_P
        {
            t = Function.createFunction(
                    (FunctionConstructor) Symbol.putOrGet(
                    FunctionConstructor.class, s.getText()), list);
        }
    ;

/**
* Matches a constant, which can be a lower-case word, a number or a
* quoted string.
* @param bvs the list of bound varibles so far.
* @param others the list of free varibles or constants so far.
* @return the function representing this constant.
*/
constant [ArrayList bvs, HashMap others]
    returns [Term t = null]
    {
        String name = null;
    }
    : (a:LOWER_WORD
            { name = a.getText(); }
        | b:NUMBER
            { name = b.getText(); }
        | c:QUOTED_STRING
            { name = c.getText(); }
        )
        {
            Variable bMatch = null;
            
            // Is the identifier in the list of bound variables?
            for (int i = 0; i < bvs.size(); ++i)
            {
                Variable temp = (Variable) bvs.get(i);
                if (((Variable) bvs.get(i)).getExternalName().equals(name))
                {
                    bMatch = (Variable) bvs.get(i);
                    break;
                }
            }
            if (bMatch != null)
                t = bMatch;
            else
            {
                if (this.inTarget)
                {
                    // Is the identifier in the map of constants?
                    if (others.containsKey(name))
                        t = (Term) others.get(name);
                    else
                        t = Function.createNewConstant(name);
                }
                else
                {
                    // Is the identifier in the list of free variables?
                    Variable freeMatch = null;
                    if (others.containsKey(name))
                        t = (Term) others.get(name);
                    else
                        t = Variable.createNewSequentVar(name);
                }
            }
        }
    ;

/**
* Matches a variable, which is simple an upper-case word.
* @param bvs the list of bound varibles so far.
* @param others the list of free varibles or constants so far.
* @return a variable with the matched name.  If we've seen that
* variable before, use that object instead of making a new one.
*/
variable [ArrayList bvs, HashMap others]
    returns [Term t = null]
    : a:UPPER_WORD
        {
            String name = a.getText();
            Variable bMatch = null;
            
            // Is the identifier in the list of bound variables?
            for (int i = 0; i < bvs.size(); ++i)
            {
                Variable temp = (Variable) bvs.get(i);
                if (((Variable) bvs.get(i)).getExternalName().equals(name))
                {
                    bMatch = (Variable) bvs.get(i);
                    break;
                }
            }
            if (bMatch != null)
                t = bMatch;
            else
            {
                if (this.inTarget)
                {
                    // Is the identifier in the map of constants?
                    if (others.containsKey(name))
                        t = (Term) others.get(name);
                    else
                        t = Function.createNewConstant(name);
                }
                else
                {
                    // Is the identifier in the list of free variables?
                    Variable freeMatch = null;
                    if (others.containsKey(name))
                        t = (Term) others.get(name);
                    else
                        t = Variable.createNewSequentVar(name);
                }
            }
        }
    ;

/**
* Matches a file include element.
* @return the filename that is between the quotes.
*/
include
    returns [String filename = null]
    : "include" OPEN_P f:QUOTED_STRING (formulaSelection)? CLOSE_P PERIOD
        { filename = f.getText(); }
    ;

/**
* Matches a formula selection in the file include.  Currently this is
* not being used.
*/
formulaSelection
    : LOWER_WORD
    | OPEN_B LOWER_WORD (COMMA LOWER_WORD)+ CLOSE_B
    ;


/**
* A lexer generated by the <a href="http://www.antlr.org/">ANTLR</a>
* tools.  Matches a stream of characters, packaging them into tokens
* to be shipped off to a FOFParser.
* @author ANTLR
* @author <a href="mailto:walpet@bethel.edu">Pete Wall</a>
* @version 1.0
*/
class FOFScanner extends Lexer;

options
{
    k = 3;
    charVocabulary='\3'..'\377';
    filter = WS;
}

/**
* Matches a quoted string, which is a single or double quote, followed
* by several characters, followed by another single or double quote.
* Note that this does not allow for the '\' to be used to escape a
* single or double quote.
*/
QUOTED_STRING
    options
    {
        paraphrase = "a quoted string";
    }
    : '"'! (~('"'))* '"'!
    | '\''! (~('\''))* '\''!
    ;

/**
* Matches an opening parenthesis.
*/
OPEN_P
    options
    {
        paraphrase = "an opening paren";
    }
    : '('
    ;

/**
* Matches an closing parenthesis.
*/
CLOSE_P
    options
    {
        paraphrase = "a closing paren";
    }
    : ')'
    ;

/**
* Matches an opening bracket.
*/
OPEN_B
    options
    {
        paraphrase = "an opening bracket";
    }
    : '['
    ;

/**
* Matches an closing bracket.
*/
CLOSE_B
    options
    {
        paraphrase = "a closing bracket";
    }
    : ']'
    ;

/**
* Matches a upper-case word.
*/
UPPER_WORD
    : ('A'..'Z') (('a'..'z')|('A'..'Z')|('0'..'9')|UNDERSCORE)*
    ;

/**
* Matches an lower-case word.
*/
LOWER_WORD
    : ('a'..'z') (('a'..'z')|('A'..'Z')|('0'..'9')|UNDERSCORE)*
    ;

/**
* Matches a number.
*/
NUMBER
    : ('0'..'9')+ (PERIOD ('0'..'9')+)?
    ;

/**
* Matches an underscore.
*/
UNDERSCORE
    : '_'
    ;

/**
* Matches a colon.
*/
COLON
    : ':'
    ;

/**
* Matches a comma.
*/
COMMA
    : ','
    ;

/**
* Matches a period.
*/
PERIOD
    : '.'
    ;

/**
* Matches a dash.
*/
DASH
    : '-'
    ;

/**
* Matches a tilde.
*/
TILDE
    : '~'
    ;

/**
* Matches an and.
*/
AND
    : '&'
    ;

/**
* Matches a nand.
*/
N_AND
    : '~' '&'
    ;

/**
* Matches an or.
*/
OR
    : '|'
    ;

/**
* Matches a nor.
*/
N_OR
    : '~' '|'
    ;

/**
* Matches an if-and-only-if.
*/
IFF
    : '<' '=' '>'
    ;

/**
* Matches an exclusive or.
*/
XOR
    : '<' '~' '>'
    ;

/**
* Matches an implies.
*/
IMPLIES
    : '=' '>'
    ;

/**
* Matches a reverse implies.
*/
R_IMPLIES
    : '<' '='
    ;

/**
* Matches a quantifier, which is either "!" for forall or "?" for
* for-some.
*/
QUANTIFIER
    : '!'
    | '?'
    ;

/**
* Matches a comment, and promptly ignores it.  They do not get passed
* to the parser
*/
COMMENT
    : ( '%' (~('\n'|'\r'))* ('\n'|'\r'('\n')?)
      | '#' (~('\n'|'\r'))* ('\n'|'\r'('\n')?)
      )
        {
            $setType(Token.SKIP);
            newline();
        }
    ;

/**
* Matches whitespace, which is also ignored and not passed to the
* parser.
*/
protected
WS
    : (' '|'\t'|'\f')
        {
            $setType(Token.SKIP);
        }
    ;

/**
* Matches newline characters.  They do not get passed to the parser.
*/
NEWLINE
    : ('\r' | '\n' | '\r' '\n')
        {
            $setType(Token.SKIP);
            newline();
        }
    ;
